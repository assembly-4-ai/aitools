// --- Placeholder for nlohmann/json.hpp ---
#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_
#include <string>
#include <vector>
#include <map>
#include <stdexcept> // For exceptions
namespace nlohmann {
  class json {
  public:
    using object_t = std::map<std::string, json>;
    using array_t = std::vector<json>;
    json() = default;
    json(std::nullptr_t) {}
    json(const char* s) : value_string(s) {}
    json(const std::string& s) : value_string(s) {}
    json(int){} json(double){} json(bool){}
    json(const object_t& obj) {}
    json(const array_t& arr) {}

    static json parse(const std::string& s) { return json(); }
    template<typename T> T get() const { if constexpr (std::is_same_v<T, std::string>) return value_string; return T{}; }
    template<typename T> void get_to(T& val) const { val = get<T>(); }


    bool is_object() const { return false; }
    bool is_array() const { return false; }
    bool is_string() const { return !value_string.empty(); }
    bool is_null() const { return false; }
    bool contains(const std::string&) const { return false; }
    std::string dump(int indent = -1) const { return "{}"; }
    json& operator[](const std::string& key) { static json instance; return instance; }
    const json& operator[](const std::string& key) const { static json instance; return instance; }
    json& operator[](size_t idx) { static json instance; return instance; }
    const json& operator[](size_t idx) const { static json instance; return instance; }

    void push_back(const json& val) {}
    bool empty() const { return true; }
    size_t size() const { return 0; }

    // Iterators (minimal for items())
    struct iterator {
        using iterator_category = std::input_iterator_tag;
        using value_type = std::pair<const std::string, json>; // Simplified for items()
        using difference_type = std::ptrdiff_t;
        using pointer = value_type*;
        using reference = value_type&;
        iterator& operator++() { return *this; }
        bool operator!=(const iterator&) const { return false; }
        value_type operator*() const { return {"", json()}; }
    };
    iterator begin() const { return iterator(); }
    iterator end() const { return iterator(); }

    // For items()
    struct items_proxy { // To enable range-based for
        iterator begin() const { return iterator(); }
        iterator end() const { return iterator(); }
    };
    items_proxy items() const { return items_proxy(); }


    // For type checking and access, e.g. j.at("key").get_to(ci.description);
    json& at(const std::string& key) { return operator[](key); }
    const json& at(const std::string& key) const { return operator[](key); }
    json& at(size_t idx) { return operator[](idx); }
    const json& at(size_t idx) const { return operator[](idx); }


    // For NLOHMANN_DEFINE_TYPE_INTRUSIVE
    template<typename BasicJsonType, typename T, typename... Args>
    friend struct detail::external_constructor;
    template<typename T>
    T value(const std::string& key, const T& default_value) const {
        if (contains(key)) return at(key).get<T>();
        return default_value;
    }
     bool is_boolean() const {return false;}
     bool is_number() const {return false;}


  private:
    std::string value_string; // Store string values for simplicity
  };

  // Exceptions
  struct parse_error : std::runtime_error { using runtime_error::runtime_error; };
  struct type_error : std::runtime_error { using runtime_error::runtime_error; };
  struct out_of_range : std::runtime_error { using runtime_error::runtime_error; };
  struct other_error : std::runtime_error { using runtime_error::runtime_error; };


    namespace detail { // Needed for NLOHMANN_DEFINE_TYPE_INTRUSIVE to compile
        template<typename BasicJsonType, typename T, typename... Args>
        struct external_constructor {
             static void construct(BasicJsonType& j, const T& obj) {
                // To avoid unused warnings if NLOHMANN_DEFINE_TYPE_INTRUSIVE is empty
                // This would normally call to_json generated by the macro
             }
        };
    }
}
// This macro is complex; for a placeholder, a simple define is enough
// to let the code compile. The actual macro generates to_json/from_json.
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...) \
    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { \
        /* Actual macro generates assignments here based on ... */ \
    } \
    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { \
        /* Actual macro generates assignments here based on ... */ \
    }

#endif